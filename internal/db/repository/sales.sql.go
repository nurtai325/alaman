// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sales.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLeadCount = `-- name: GetLeadCount :one
SELECT COUNT(*) FROM leads
WHERE created_at >= $1
`

func (q *Queries) GetLeadCount(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, getLeadCount, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNewLeadsCount = `-- name: GetNewLeadsCount :one
SELECT COUNT(*) FROM leads
WHERE created_at >= $1
`

func (q *Queries) GetNewLeadsCount(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, getNewLeadsCount, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSaleItemsByTime = `-- name: GetSaleItemsByTime :many
SELECT si.id, si.product_id, si.sale_id, si.quantity, si.created_at, p.price, p.name AS product_name, p.sale_count FROM sale_items AS si
INNER JOIN sales s ON si.sale_id = s.id
INNER JOIN products p ON si.product_id = p.id
WHERE s.payment_at >= $1
`

type GetSaleItemsByTimeRow struct {
	ID          int32
	ProductID   int32
	SaleID      int32
	Quantity    int32
	CreatedAt   pgtype.Timestamptz
	Price       int32
	ProductName string
	SaleCount   int32
}

func (q *Queries) GetSaleItemsByTime(ctx context.Context, paymentAt pgtype.Timestamptz) ([]GetSaleItemsByTimeRow, error) {
	rows, err := q.db.Query(ctx, getSaleItemsByTime, paymentAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSaleItemsByTimeRow
	for rows.Next() {
		var i GetSaleItemsByTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.SaleID,
			&i.Quantity,
			&i.CreatedAt,
			&i.Price,
			&i.ProductName,
			&i.SaleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSales = `-- name: GetSales :many
SELECT s.id, s.type, s.delivery_type, s.payment_at, s.full_sum, s.delivery_cost, s.loan_cost, s.items_sum, s.created_at, u.id AS user_id, u.name AS user_name FROM sales AS s
INNER JOIN leads l ON l.sale_id = s.id
INNER JOIN users u ON l.user_id = u.id
WHERE s.payment_at >= $1
`

type GetSalesRow struct {
	ID           int32
	Type         string
	DeliveryType pgtype.Text
	PaymentAt    pgtype.Timestamptz
	FullSum      float32
	DeliveryCost float32
	LoanCost     float32
	ItemsSum     float32
	CreatedAt    pgtype.Timestamptz
	UserID       int32
	UserName     string
}

func (q *Queries) GetSales(ctx context.Context, paymentAt pgtype.Timestamptz) ([]GetSalesRow, error) {
	rows, err := q.db.Query(ctx, getSales, paymentAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesRow
	for rows.Next() {
		var i GetSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.DeliveryType,
			&i.PaymentAt,
			&i.FullSum,
			&i.DeliveryCost,
			&i.LoanCost,
			&i.ItemsSum,
			&i.CreatedAt,
			&i.UserID,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoldLeadCount = `-- name: GetSoldLeadCount :one
SELECT COUNT(*) FROM leads
WHERE created_at >= $1 AND sale_id IS NOT NULL
`

func (q *Queries) GetSoldLeadCount(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, getSoldLeadCount, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSum = `-- name: GetSum :one
SELECT SUM(full_sum) FROM sales AS s
INNER JOIN leads l ON l.sale_id = s.id
WHERE s.payment_at >= $1
`

func (q *Queries) GetSum(ctx context.Context, paymentAt pgtype.Timestamptz) (float32, error) {
	row := q.db.QueryRow(ctx, getSum, paymentAt)
	var sum float32
	err := row.Scan(&sum)
	return sum, err
}
