// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: leads.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignLead = `-- name: AssignLead :one
UPDATE leads
SET user_id = $2
WHERE id = $1
RETURNING id, name, address, phone, completed, user_id, sale_id, created_at, sold_at
`

type AssignLeadParams struct {
	ID     int32
	UserID pgtype.Int4
}

func (q *Queries) AssignLead(ctx context.Context, arg AssignLeadParams) (Lead, error) {
	row := q.db.QueryRow(ctx, assignLead, arg.ID, arg.UserID)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.Completed,
		&i.UserID,
		&i.SaleID,
		&i.CreatedAt,
		&i.SoldAt,
	)
	return i, err
}

const completeLead = `-- name: CompleteLead :one
UPDATE leads
SET completed = true
WHERE id = $1
RETURNING id, name, address, phone, completed, user_id, sale_id, created_at, sold_at
`

func (q *Queries) CompleteLead(ctx context.Context, id int32) (Lead, error) {
	row := q.db.QueryRow(ctx, completeLead, id)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.Completed,
		&i.UserID,
		&i.SaleID,
		&i.CreatedAt,
		&i.SoldAt,
	)
	return i, err
}

const getAssignedLeads = `-- name: GetAssignedLeads :many
SELECT l.id, l.name, l.address, l.phone, l.completed, l.user_id, l.sale_id, l.created_at, l.sold_at, u.name AS user_name FROM leads AS l
INNER JOIN users u ON l.user_id = u.id
WHERE user_id IS NOT NULL AND sale_id IS NULL
ORDER BY created_at DESC
`

type GetAssignedLeadsRow struct {
	ID        int32
	Name      pgtype.Text
	Address   pgtype.Text
	Phone     string
	Completed bool
	UserID    pgtype.Int4
	SaleID    pgtype.Int4
	CreatedAt pgtype.Timestamptz
	SoldAt    pgtype.Timestamptz
	UserName  string
}

func (q *Queries) GetAssignedLeads(ctx context.Context) ([]GetAssignedLeadsRow, error) {
	rows, err := q.db.Query(ctx, getAssignedLeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignedLeadsRow
	for rows.Next() {
		var i GetAssignedLeadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Phone,
			&i.Completed,
			&i.UserID,
			&i.SaleID,
			&i.CreatedAt,
			&i.SoldAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletedLeads = `-- name: GetCompletedLeads :many
SELECT l.id, l.name, l.address, l.phone, l.completed, l.user_id, l.sale_id, l.created_at, l.sold_at, u.name AS user_name, s.full_sum, s.delivery_type, s.payment_at FROM leads AS l
INNER JOIN users u ON l.user_id = u.id
INNER JOIN sales s ON l.sale_id = s.id
WHERE user_id IS NOT NULL AND sale_id IS NOT NULL AND completed = true
ORDER BY sold_at ASC
`

type GetCompletedLeadsRow struct {
	ID           int32
	Name         pgtype.Text
	Address      pgtype.Text
	Phone        string
	Completed    bool
	UserID       pgtype.Int4
	SaleID       pgtype.Int4
	CreatedAt    pgtype.Timestamptz
	SoldAt       pgtype.Timestamptz
	UserName     string
	FullSum      float32
	DeliveryType pgtype.Text
	PaymentAt    pgtype.Timestamptz
}

func (q *Queries) GetCompletedLeads(ctx context.Context) ([]GetCompletedLeadsRow, error) {
	rows, err := q.db.Query(ctx, getCompletedLeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompletedLeadsRow
	for rows.Next() {
		var i GetCompletedLeadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Phone,
			&i.Completed,
			&i.UserID,
			&i.SaleID,
			&i.CreatedAt,
			&i.SoldAt,
			&i.UserName,
			&i.FullSum,
			&i.DeliveryType,
			&i.PaymentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullLead = `-- name: GetFullLead :one
SELECT l.id, l.name, l.address, l.phone, l.completed, l.user_id, l.sale_id, l.created_at, l.sold_at, u.name AS user_name, u.phone AS user_phone, s.full_sum, s.delivery_cost, s.loan_cost, s.delivery_type, s.payment_at, s.type AS sale_type
FROM leads AS l
INNER JOIN users u ON l.user_id = u.id
INNER JOIN sales s ON l.sale_id = s.id
WHERE l.id = $1
LIMIT 1
`

type GetFullLeadRow struct {
	ID           int32
	Name         pgtype.Text
	Address      pgtype.Text
	Phone        string
	Completed    bool
	UserID       pgtype.Int4
	SaleID       pgtype.Int4
	CreatedAt    pgtype.Timestamptz
	SoldAt       pgtype.Timestamptz
	UserName     string
	UserPhone    string
	FullSum      float32
	DeliveryCost float32
	LoanCost     float32
	DeliveryType pgtype.Text
	PaymentAt    pgtype.Timestamptz
	SaleType     string
}

func (q *Queries) GetFullLead(ctx context.Context, id int32) (GetFullLeadRow, error) {
	row := q.db.QueryRow(ctx, getFullLead, id)
	var i GetFullLeadRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.Completed,
		&i.UserID,
		&i.SaleID,
		&i.CreatedAt,
		&i.SoldAt,
		&i.UserName,
		&i.UserPhone,
		&i.FullSum,
		&i.DeliveryCost,
		&i.LoanCost,
		&i.DeliveryType,
		&i.PaymentAt,
		&i.SaleType,
	)
	return i, err
}

const getInDeliveryLeads = `-- name: GetInDeliveryLeads :many
SELECT l.id, l.name, l.address, l.phone, l.completed, l.user_id, l.sale_id, l.created_at, l.sold_at, u.name AS user_name, s.full_sum, s.delivery_type, s.payment_at FROM leads AS l
INNER JOIN users u ON l.user_id = u.id
INNER JOIN sales s ON l.sale_id = s.id
WHERE user_id IS NOT NULL AND sale_id IS NOT NULL AND completed = false
ORDER BY sold_at ASC
`

type GetInDeliveryLeadsRow struct {
	ID           int32
	Name         pgtype.Text
	Address      pgtype.Text
	Phone        string
	Completed    bool
	UserID       pgtype.Int4
	SaleID       pgtype.Int4
	CreatedAt    pgtype.Timestamptz
	SoldAt       pgtype.Timestamptz
	UserName     string
	FullSum      float32
	DeliveryType pgtype.Text
	PaymentAt    pgtype.Timestamptz
}

func (q *Queries) GetInDeliveryLeads(ctx context.Context) ([]GetInDeliveryLeadsRow, error) {
	rows, err := q.db.Query(ctx, getInDeliveryLeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInDeliveryLeadsRow
	for rows.Next() {
		var i GetInDeliveryLeadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Phone,
			&i.Completed,
			&i.UserID,
			&i.SaleID,
			&i.CreatedAt,
			&i.SoldAt,
			&i.UserName,
			&i.FullSum,
			&i.DeliveryType,
			&i.PaymentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeadByPhone = `-- name: GetLeadByPhone :one
SELECT id, name, address, phone, completed, user_id, sale_id, created_at, sold_at FROM leads 
WHERE phone = $1 
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLeadByPhone(ctx context.Context, phone string) (Lead, error) {
	row := q.db.QueryRow(ctx, getLeadByPhone, phone)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.Completed,
		&i.UserID,
		&i.SaleID,
		&i.CreatedAt,
		&i.SoldAt,
	)
	return i, err
}

const getNewLeads = `-- name: GetNewLeads :many
SELECT id, name, address, phone, completed, user_id, sale_id, created_at, sold_at FROM leads AS l
WHERE user_id IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetNewLeads(ctx context.Context) ([]Lead, error) {
	rows, err := q.db.Query(ctx, getNewLeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lead
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Phone,
			&i.Completed,
			&i.UserID,
			&i.SaleID,
			&i.CreatedAt,
			&i.SoldAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSaleItems = `-- name: GetSaleItems :many
SELECT s.id, s.product_id, s.sale_id, s.quantity, s.created_at, p.name AS product_name FROM sale_items AS s
INNER JOIN products p ON s.product_id = p.id
WHERE s.sale_id = $1
`

type GetSaleItemsRow struct {
	ID          int32
	ProductID   int32
	SaleID      int32
	Quantity    int32
	CreatedAt   pgtype.Timestamptz
	ProductName string
}

func (q *Queries) GetSaleItems(ctx context.Context, saleID int32) ([]GetSaleItemsRow, error) {
	rows, err := q.db.Query(ctx, getSaleItems, saleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSaleItemsRow
	for rows.Next() {
		var i GetSaleItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.SaleID,
			&i.Quantity,
			&i.CreatedAt,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLead = `-- name: InsertLead :one
INSERT INTO leads(phone)
VALUES ($1)
RETURNING id, name, address, phone, completed, user_id, sale_id, created_at, sold_at
`

func (q *Queries) InsertLead(ctx context.Context, phone string) (Lead, error) {
	row := q.db.QueryRow(ctx, insertLead, phone)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.Completed,
		&i.UserID,
		&i.SaleID,
		&i.CreatedAt,
		&i.SoldAt,
	)
	return i, err
}

const insertSale = `-- name: InsertSale :one
INSERT INTO sales(type, full_sum, delivery_cost, loan_cost, items_sum, delivery_type, payment_at)
VALUES($1, $2, $3, $4, $5, $6, $7)
RETURNING id, type, delivery_type, payment_at, full_sum, delivery_cost, loan_cost, items_sum, created_at
`

type InsertSaleParams struct {
	Type         string
	FullSum      float32
	DeliveryCost float32
	LoanCost     float32
	ItemsSum     float32
	DeliveryType pgtype.Text
	PaymentAt    pgtype.Timestamptz
}

func (q *Queries) InsertSale(ctx context.Context, arg InsertSaleParams) (Sale, error) {
	row := q.db.QueryRow(ctx, insertSale,
		arg.Type,
		arg.FullSum,
		arg.DeliveryCost,
		arg.LoanCost,
		arg.ItemsSum,
		arg.DeliveryType,
		arg.PaymentAt,
	)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.DeliveryType,
		&i.PaymentAt,
		&i.FullSum,
		&i.DeliveryCost,
		&i.LoanCost,
		&i.ItemsSum,
		&i.CreatedAt,
	)
	return i, err
}

const insertSaleItem = `-- name: InsertSaleItem :one
INSERT INTO sale_items(product_id, sale_id, quantity)
VALUES($1, $2, $3)
RETURNING id, product_id, sale_id, quantity, created_at
`

type InsertSaleItemParams struct {
	ProductID int32
	SaleID    int32
	Quantity  int32
}

func (q *Queries) InsertSaleItem(ctx context.Context, arg InsertSaleItemParams) (SaleItem, error) {
	row := q.db.QueryRow(ctx, insertSaleItem, arg.ProductID, arg.SaleID, arg.Quantity)
	var i SaleItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.SaleID,
		&i.Quantity,
		&i.CreatedAt,
	)
	return i, err
}

const sellLead = `-- name: SellLead :one
UPDAte leads
SET sale_id = $2, sold_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, address, phone, completed, user_id, sale_id, created_at, sold_at
`

type SellLeadParams struct {
	ID     int32
	SaleID pgtype.Int4
}

func (q *Queries) SellLead(ctx context.Context, arg SellLeadParams) (Lead, error) {
	row := q.db.QueryRow(ctx, sellLead, arg.ID, arg.SaleID)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.Completed,
		&i.UserID,
		&i.SaleID,
		&i.CreatedAt,
		&i.SoldAt,
	)
	return i, err
}

const setLeadInfo = `-- name: SetLeadInfo :one
UPDATE leads
SET name = $2, address = $3
WHERE id = $1
RETURNING id, name, address, phone, completed, user_id, sale_id, created_at, sold_at
`

type SetLeadInfoParams struct {
	ID      int32
	Name    pgtype.Text
	Address pgtype.Text
}

func (q *Queries) SetLeadInfo(ctx context.Context, arg SetLeadInfoParams) (Lead, error) {
	row := q.db.QueryRow(ctx, setLeadInfo, arg.ID, arg.Name, arg.Address)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.Completed,
		&i.UserID,
		&i.SaleID,
		&i.CreatedAt,
		&i.SoldAt,
	)
	return i, err
}
